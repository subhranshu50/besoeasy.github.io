<!DOCTYPE html>
<html>
<head>
    <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
<style>
html, body {
  height: 100%;
  width: 100%;
  padding: 0px;
  margin: 0px;
  overflow: hidden;
  display: flex;
}


* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

*:before, *:after {
  content: '';
  display: block;
  position: absolute;
  box-sizing: border-box;
}



.szene {
  position: absolute;
  left: 50%;
  bottom: 0;
  width: 800px;
  height: 400px;
  margin-left: -400px;
  overflow: hidden;
}

.szene div {
  position: absolute;
}

.image {
  width: 250px;
  color: #888;
  border: 8px solid #444;
  background: #eee;
}

.image.i1 { top: 70px; left: 80px; height: 145px;}
.image.i2 { top: 20px; left: 400px;   height: 250px; }

.image .nail {
  top: -30px;
  left: 50%;
  width: 8px;
  height: 8px;
  margin-left: -4px;
  border-radius: 50%;
  background: #444;
}

.image .nail:before,
.image .nail:after {
  top: -5px;
  width: 1px;
  height: 35px;
  background: #444;
}

.image .nail:before { left: -11px; transform: rotate(55deg); }
.image .nail:after { left: 19px; transform: rotate(-55deg); }

.head {
  bottom: 90px;
  left: 58.5%;
  width: 85px;
  height: 85px;
  border-radius: 50%;
  background: #cfa992;
}

.head .eyes {
  top: 58px;
  left: 30px;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: #444;
  box-shadow: 20px 0 0 #444;
  animation: 8s eyes ease infinite;
}

@keyframes eyes {
  0% { transform: translate3d(0,0,0); }
  5% { transform: translate3d(0,-18px,0); }
  10% { transform: translate3d(0,-19px,0); }
  15% { transform: translate3d(-15px,-18px,0); }
  20% { transform: translate3d(-15px,-18px,0); }
  25% { transform: translate3d(15px,-18px,0); }
  30% { transform: translate3d(15px,-18px,0); }
  35% { transform: translate3d(0,-18px,0); }
  40% { transform: translate3d(0,-18px,0); }
  45% { transform: translate3d(0,0,0); }
  100% { transform: translate3d(0,0,0); }
}



.table {
  bottom: 15px;
  left: 35%;
  width: 400px;
  height: 15px;
  background: #444;
}

.table:before,
.table:after {
  top: 15px;
  width: 10px;
  height: 20px;
  border-top: 3px solid #aaa;
  background: #eee;
}

.table:before { left: 20px; }
.table:after { right: 20px; }

.laptop {
  bottom: 35px;
  left: 55%;
  width: 140px;
  height: 70px;
  border-radius: 2px 2px 0 0;
  background: #2b1d2c;
}

.laptop:before {
  top: 50%;
  left: 50%;
  width: 18px;
  height: 18px;
  margin: -9px 0 0 -9px;
  border-radius: 50%;
  background: #fff;
}

.laptop:after {
  top: 70px;
  left: -5px;
  width: 150px;
  height: 5px;
  border-radius: 2px 2px 0 0;
  background: #888;
}

.mouse {
  bottom: 30px;
  left: 50%;
  width: 20px;
  height: 6px;
  border-bottom: 2px solid #888;
  border-radius: 25%;
  background: #ddd;
}

.notes {
  bottom: 30px;
  left: 75%;
  width: 60px;
  height: 12px;
  background: #fff;
  border: 4px solid #222;
  border-radius: 4px;
  border-left: 0;
}

.lamp {
  bottom: 30px;
  left: 40%;
  width: 40px;
  height: 20px;
  border-radius: 80px 80px 0 0;
  background: #eee;
}

.lamp:before,
.lamp:after {

  width: 6px;
  height: 80px;
  background: #ccc;
}

.lamp:before { top: -70px; left: 8px; transform: rotate(-15deg); }
.lamp:after { top: -108px; left: 30px; transform: rotate(75deg) }

.lamp .top {
  top: -75px;
  left: 45px;
  width: 50px;
  height: 25px;
  border-radius: 100px 100px 0 0;
  background: #c8fafe;
  transform: rotate(-15deg);
}

.headphones {
  bottom: 85px;
  left: 57%;
  width: 110px;
  height: 100px;
  border-radius: 50%;
  border-top: 10px solid #f585b7;
}

.headphones:before,
.headphones:after {
  width: 20px;
  height: 40px;
  top: 20px;
  background: #ddd;
}

.headphones:before {
  left: -8px;
  border-radius: 80px 0 0 80px;
  border-right: 3px solid #444;
}

.headphones:after {
  right: -7px;
  border-radius: 0 80px 80px 0;
  border-left: 3px solid #444;
}

.trash {
  bottom: 15px;
  left: 20%;
  width: 100px;
  height: 8px;
  background: #444;
}

.trash:after {
  top: 8px;
  left: 3px;
  width: 94px;
  height: 25px;
  border-radius: 0 0 50px 50px;
  background: #555;
}

.trash .paper {


  width: 25px;
  height: 50px;
  border: 1px solid #555;
  background: #ddd;
}

.trash .paper.p1 {
  top: -15px;
  left: 10px;
  transform: rotate(-20deg);
}

.trash .paper.p2 {
  top: -12px;
  left: 30px;
  transform: rotate(-40deg);
}

.trash .paper.p3 {
  top: -15px;
  left: 60px;
  transform: rotate(10deg);
}

.trash .paper.p4 {
  top: -12px;
  left: 30px;
  transform: rotate(65deg);
}




.float{
	position:fixed;
	width:60px;
	height:60px;
	bottom:40px;
	right:40px;
	background-color:#0C9;
	color:#FFF;
	border-radius:50px;
	text-align:center;
	box-shadow: 2px 2px 3px #999;
}

.my-float{
	margin-top:22px;
}


</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
<script>



(function(global){
  var module = global.noise = {};

  function Grad(x, y, z) {
    this.x = x; this.y = y; this.z = z;
  }
  
  Grad.prototype.dot2 = function(x, y) {
    return this.x*x + this.y*y;
  };

  Grad.prototype.dot3 = function(x, y, z) {
    return this.x*x + this.y*y + this.z*z;
  };

  var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
               new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
               new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];

  var p = [151,160,137,91,90,15,
  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
  // To remove the need for index wrapping, double the permutation table length
  var perm = new Array(512);
  var gradP = new Array(512);

  module.seed = function(seed) {
    if(seed > 0 && seed < 1) {
      // Scale the seed out
      seed *= 65536;
    }

    seed = Math.floor(seed);
    if(seed < 256) {
      seed |= seed << 8;
    }

    for(var i = 0; i < 256; i++) {
      var v;
      if (i & 1) {
        v = p[i] ^ (seed & 255);
      } else {
        v = p[i] ^ ((seed>>8) & 255);
      }

      perm[i] = perm[i + 256] = v;
      gradP[i] = gradP[i + 256] = grad3[v % 12];
    }
  };

  module.seed(0);

  /*
  for(var i=0; i<256; i++) {
    perm[i] = perm[i + 256] = p[i];
    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
  }*/

  // Skewing and unskewing factors for 2, 3, and 4 dimensions
  var F2 = 0.5*(Math.sqrt(3)-1);
  var G2 = (3-Math.sqrt(3))/6;

  var F3 = 1/3;
  var G3 = 1/6;

  // 2D simplex noise
  module.simplex2 = function(xin, yin) {
    var n0, n1, n2; // Noise contributions from the three corners
    // Skew the input space to determine which simplex cell we're in
    var s = (xin+yin)*F2; // Hairy factor for 2D
    var i = Math.floor(xin+s);
    var j = Math.floor(yin+s);
    var t = (i+j)*G2;
    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
    var y0 = yin-j+t;
    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      i1=1; j1=0;
    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      i1=0; j1=1;
    }
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    var y1 = y0 - j1 + G2;
    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
    var y2 = y0 - 1 + 2 * G2;
    // Work out the hashed gradient indices of the three simplex corners
    i &= 255;
    j &= 255;
    var gi0 = gradP[i+perm[j]];
    var gi1 = gradP[i+i1+perm[j+j1]];
    var gi2 = gradP[i+1+perm[j+1]];
    // Calculate the contribution from the three corners
    var t0 = 0.5 - x0*x0-y0*y0;
    if(t0<0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
    }
    var t1 = 0.5 - x1*x1-y1*y1;
    if(t1<0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot2(x1, y1);
    }
    var t2 = 0.5 - x2*x2-y2*y2;
    if(t2<0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot2(x2, y2);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70 * (n0 + n1 + n2);
  };

  // 3D simplex noise
  module.simplex3 = function(xin, yin, zin) {
    var n0, n1, n2, n3; // Noise contributions from the four corners

    // Skew the input space to determine which simplex cell we're in
    var s = (xin+yin+zin)*F3; // Hairy factor for 2D
    var i = Math.floor(xin+s);
    var j = Math.floor(yin+s);
    var k = Math.floor(zin+s);

    var t = (i+j+k)*G3;
    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
    var y0 = yin-j+t;
    var z0 = zin-k+t;

    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
    // Determine which simplex we are in.
    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
    if(x0 >= y0) {
      if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
      else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
      else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
    } else {
      if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
      else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
      else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
    }
    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
    // c = 1/6.
    var x1 = x0 - i1 + G3; // Offsets for second corner
    var y1 = y0 - j1 + G3;
    var z1 = z0 - k1 + G3;

    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
    var y2 = y0 - j2 + 2 * G3;
    var z2 = z0 - k2 + 2 * G3;

    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
    var y3 = y0 - 1 + 3 * G3;
    var z3 = z0 - 1 + 3 * G3;

    // Work out the hashed gradient indices of the four simplex corners
    i &= 255;
    j &= 255;
    k &= 255;
    var gi0 = gradP[i+   perm[j+   perm[k   ]]];
    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];
    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];
    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];

    // Calculate the contribution from the four corners
    var t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
    if(t0<0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient
    }
    var t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
    if(t1<0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
    }
    var t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
    if(t2<0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
    }
    var t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
    if(t3<0) {
      n3 = 0;
    } else {
      t3 *= t3;
      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 32 * (n0 + n1 + n2 + n3);

  };

  // ##### Perlin noise stuff

  function fade(t) {
    return t*t*t*(t*(t*6-15)+10);
  }

  function lerp(a, b, t) {
    return (1-t)*a + t*b;
  }

  // 2D Perlin Noise
  module.perlin2 = function(x, y) {
    // Find unit grid cell containing point
    var X = Math.floor(x), Y = Math.floor(y);
    // Get relative xy coordinates of point within that cell
    x = x - X; y = y - Y;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255; Y = Y & 255;

    // Calculate noise contributions from each of the four corners
    var n00 = gradP[X+perm[Y]].dot2(x, y);
    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);
    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);
    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);

    // Compute the fade curve value for x
    var u = fade(x);

    // Interpolate the four results
    return lerp(
        lerp(n00, n10, u),
        lerp(n01, n11, u),
       fade(y));
  };

  // 3D Perlin Noise
  module.perlin3 = function(x, y, z) {
    // Find unit grid cell containing point
    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);
    // Get relative xyz coordinates of point within that cell
    x = x - X; y = y - Y; z = z - Z;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255; Y = Y & 255; Z = Z & 255;

    // Calculate noise contributions from each of the eight corners
    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);
    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);
    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);
    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);
    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);
    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);
    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);
    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);

    // Compute the fade curve value for x, y, z
    var u = fade(x);
    var v = fade(y);
    var w = fade(z);

    // Interpolate
    return lerp(
        lerp(
          lerp(n000, n100, u),
          lerp(n001, n101, u), w),
        lerp(
          lerp(n010, n110, u),
          lerp(n011, n111, u), w),
       v);
  };

})(this);

</script>
<script>
	$(document).ready(function(){
		var slider = new gooSlider('body');
		var l1,l2;
		$('body').click(function(){
			var c = 'hsla('+ (Math.floor(Math.random()*7) * 50) +',53%, 69%, 1)';
			if(c != l1 && c != l2){
				slider.wave(c, function(){});
				l2 = l1;
				l1 = c;
			} else {
				$('body').click();
			}
		});
		
		var count = 5,
		    cur = 0;
		function start(){
			slider.wave('hsla('+ (Math.floor(Math.random()*7) * 50) +',53%, 69%, 0.8)', function(){});
			cur++;
			if(cur<count){
				setTimeout(function(){
					start();
				}, 3000)
			}
		}
		start();
	});
</script>
<script>



window.requestFrame = (function(){
	return  window.requestAnimationFrame       ||
		window.webkitRequestAnimationFrame ||
		window.mozRequestAnimationFrame    ||
		function( callback ){
		window.setTimeout(callback, 1000 / 60);
	};
})();


var gooSlider = function(parent, id){
	
	var size = {
		x: $(parent).width(),
		y: $(parent).height()
	};
	
	var canvas = $('<canvas/>').attr({width: size.x, height: size.y, id: id}).appendTo(parent),
    context = canvas.get(0).getContext("2d");
	
	var startTime = new Date().getTime(); // timing stuff
	var currentTime = 0; // more timing, it just makes it so it always falls at the same rate
	
	var dripDist = 100; // distance between each "drip"
	var dripsAmount = Math.floor(size.x / dripDist) + 2; // amount of drips that will go across screen
	waves = []; // this will contain the information for each wave (color, drip positions, etc...)
	this.waves = waves; // making the waves variable available to the outside world
	
	noise.seed(Math.random());
	
	this.wave = function(settings, call){ // this creates the wave object. You pass through the color of the "wave" and the callback for when the wave covers the screen.
		if(typeof call != 'function') { call = function(){} }
		var it = {
			drips: [],
			callback: call,
			defaults: {
				color: '#99db81',
				minSpeed: 1,
				maxSpeed: 3
			},
			settings: {}
		}; 
		
		if(typeof settings == 'object'){
			it.settings = $.extend(true, it.defaults, settings);
		} else {
			it.settings = $.extend(true, it.defaults, {color: settings});
		}
		
		for(var i = 0; i < dripsAmount; i++){
			it.drips.push(0);
		}
		waves.push(it); // add the object to the waves array so it's animated.
	}
	
	function loop(){
		var now = new Date().getTime();
		currentTime = (now - startTime) / 10000; // more timing..
		
		//context.clearRect(0,0,size.x,size.y);
		
		for(var i = 0; i <= waves.length; i++){ // for each wave
			if(waves[i] != undefined){ // make sure it's still getting animated
				var done = true;  // this tells me if we're on the last animation frame for this wave or not

				var points = []; // this will contain the points for the wave
				for(var c = 0; c < waves[i].drips.length; c++){ // for each drip in the wave
					waves[i].drips[c] += waves[i].settings.minSpeed + ((noise.simplex2((i*dripsAmount)+c,currentTime) + 1) * waves[i].settings.maxSpeed); // add the "speed" of that drop to the y position

					points.push({ // add this point to be animated
						x: dripDist*c, 
						y: waves[i].drips[c]
					});
					if(waves[i].drips[c] < size.y){ // if this point is not to the bottom of the screen yet, set done to false.  Once all points are below the screen, done will be set to true and the animation for this wave will end and the callback will be... called.
						done = false; // ^^
					}
				}
				
				if(done == true){ // The continuation of the comment above
					waves[i].callback(); // callback
					waves[i].callback = function(){}; // callback
					setTimeout(function(i){
						waves[i] = undefined; // stop this waves animation
					},50000);
				} else {
					context.beginPath(); // this is the animation
					context.strokeStyle = waves[i].settings.color; // set the color of the wave
					context.fillStyle = waves[i].settings.color; // ^^
					context.moveTo(0, 0); // move to the top left
					context.lineTo(points[0].x, points[0].y); // draw to the first point
					
					var p = 0;
					for (p = 1; p < points.length - 2; p ++){ // loop through almost all of the points, but leave the last 2 alone and we'll code that in by hand
						var xc = (points[p].x + points[p + 1].x) / 2; // math for x offset
						var yc = ((points[p].y + points[p + 1].y) / 2); // ^^ but for y

						context.quadraticCurveTo(points[p].x, points[p].y, xc, yc); // draw the curve to this new point, using the x and y offsets
					}
					// curve through the last two points
					context.quadraticCurveTo(points[p].x, points[p].y, points[p+1].x,points[p+1].y); // draw the last two by hand
					context.lineTo(size.x, 0); // draw a line to the top right so the fill works properly
					context.stroke();
					context.fill();
				}
			}
		}
		requestFrame(loop);
	}
	
	this.clear = function(){ // this will come in handy for practical uses
		waves = [];
		context.clearRect(0,0,size.x,size.y);
	}
	loop(); // start the animation
}





</script>


<title>BeSoEasy</title>
  </head>
<body>



<div class='szene'>
  <div class='image i1'>
	   <div class='nail'></div>
  <image src="http://media.giphy.com/media/SFf5PFcmviym4/giphy.gif" width="234" height="130" ></img> 
  </div>
  <div class='image i2'>
 						
  <image src="https://media.giphy.com/media/lLW0w0BRT2tiM/source.gif" width="234" height="234" ></img> 
    <div class='nail'></div>
  </div>
  <div class='head'>
    <div class='eyes'></div>
  </div>
  <div class='table'></div>
  <div class='laptop'></div>
  <div class='mouse'></div>
  <div class='notes'></div>
  <div class='lamp'>
    <div class='top'></div>
  </div>
  <div class='headphones'></div>
<div class='trash'>
    <div class='paper p1'></div>
    <div class='paper p2'></div>
    <div class='paper p3'></div>
    <div class='paper p4'></div>
  </div>
</div>


<a href="#" class="float">
    <i class="fa fa-telegram my-float"></i>
</a>
</body>
</html>